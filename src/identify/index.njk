---
title: Identify a pasta shape
layout: layout.njk
description: "Identify a pasta shape by answering a few quick questions. Mobile-friendly, one question at a time."
---

{# =============================================================================
  identify/index.njk
  ------------------------------------------------------------------------------
  PURPOSE
  - Identify pasta by narrowing down with sequential questions.
  - Mobile-first UI: big tap targets, one question at a time.
  - Show the user how each answer narrows the list using count previews.
  - When matches become small, show a live “Matches” list (helps confidence).
  - When exactly 1 match remains, DO NOT auto-redirect - show a confirmation
    state with a “View details” button so the user can verify or revise.

  IMPORTANT NOTES
  - Identify logic is embedded in this template (existing behavior).
  - No inline CSS - styling remains in /src/css/styles.css.
============================================================================= #}

{# -----------------------------------------------------------------------------
  Build identifyData JSON in the template so JS has a compact dataset.
----------------------------------------------------------------------------- #}
{% set identifyData = [] %}
{% for item in pasta %}

  {# Prefer explicit ThumbnailImage. If blank, fall back to slug.png #}
  {% set thumbCandidate = (item.ThumbnailImage or "") | replace("<ImageKitPath>", "") | trim %}
  {% set thumbRaw = thumbCandidate if thumbCandidate else (item.Slug ~ ".png") %}

  {# CSV has evolved - try multiple possible alias column names #}
  {% set alsoRaw =
    item.SearchAliases
    or item.Aliases
    or item.Synonyms
    or item.Also
    or item.Misspellings
    or ""
  %}

  {% set _ = identifyData.push({
    slug: item.Slug,
    name: item.ShapeName,
    type: item.Type or "",
    size: item.SizeClass or "",
    hollow: item.IsHollow or "",
    ridged: item.IsRidged or "",
    twisted: item.IsTwisted or "",
    curved: item.IsCurved or "",
    stuffed: item.IsStuffed or "",
    also: alsoRaw,
    thumb: thumbRaw
  }) %}
{% endfor %}

<header class="stack tight">
  <h1 class="h1">Identify a pasta shape</h1>
  <p class="muted">Answer one question at a time. You can always tap “Not sure.”</p>
</header>

<section id="identify-app" class="identify">
  <div class="card identify-card">
    <div class="identify-question">
      <p class="identify-kicker muted" id="identify-kicker">Question</p>
      <h2 class="identify-title" id="identify-title">Loading…</h2>
      <p class="identify-help muted" id="identify-help"></p>
    </div>

    <div class="identify-answers" id="identify-answers" aria-live="polite"></div>

    <div class="identify-meta">
      <span class="muted" id="identify-count"></span>
    </div>
  </div>

  <div class="card identify-results" id="identify-results" hidden>
    <div class="results-head">
      <h2 class="h2">Matches</h2>
      <p class="muted" id="identify-results-count"></p>
    </div>
    <ul class="results-list" id="identify-results-list"></ul>
  </div>

  <div class="identify-bottom-bar" role="navigation" aria-label="Identify controls">
    <button class="btn secondary" type="button" id="identify-back" disabled>Back</button>
    <button class="btn secondary" type="button" id="identify-reset">Reset</button>
    <button class="btn" type="button" id="identify-toggle-results" hidden>Show all</button>
  </div>
</section>

<script type="application/json" id="identify-data">
{{ identifyData | dump | safe }}
</script>

<script>
(function () {
  if (window.__pastaIdentifyInit) return;
  window.__pastaIdentifyInit = true;

  const $ = (sel, root = document) => root.querySelector(sel);

  const els = {
    app: $("#identify-app"),
    title: $("#identify-title"),
    kicker: $("#identify-kicker"),
    help: $("#identify-help"),
    answers: $("#identify-answers"),
    count: $("#identify-count"),
    resultsCard: $("#identify-results"),
    resultsCount: $("#identify-results-count"),
    resultsList: $("#identify-results-list"),
    btnBack: $("#identify-back"),
    btnReset: $("#identify-reset"),
    btnToggleResults: $("#identify-toggle-results"),
    dataScript: $("#identify-data"),
  };

  // ImageKit bases
  const IK_THUMBS_BASE = "https://ik.imagekit.io/mevius/pasta/thumbs/";
  const IK_IDENTIFY_BASE = "https://ik.imagekit.io/mevius/pasta/identify/";
  const FALLBACK_THUMB = "pending.png";

  // UX tuning
  const AUTO_SHOW_RESULTS_THRESHOLD = 10;

  // Results list sizing
  const DEFAULT_RESULTS_LIMIT = 60;
  const SHOW_MORE_STEP = 60;

  const isUrl = (s) => /^https?:\/\//i.test(String(s || "").trim());

  const fileNameOnly = (s) => {
    const str = String(s || "").trim();
    if (!str) return "";
    const clean = str.split("#")[0].split("?")[0];
    const parts = clean.split("/");
    return parts[parts.length - 1] || "";
  };

  const thumbUrlFor = (thumbRaw) => {
    if (isUrl(thumbRaw)) return String(thumbRaw).trim();
    const fn = fileNameOnly(thumbRaw);
    return IK_THUMBS_BASE + (fn || FALLBACK_THUMB);
  };

  const identifyIconUrlFor = (file) => IK_IDENTIFY_BASE + file;

  if (!els.app || !els.dataScript) return;

  let raw = [];
  try {
    raw = JSON.parse(els.dataScript.textContent || "[]");
  } catch (e) {
    console.error("Identify: failed to parse identify-data JSON", e);
    if (els.title) els.title.textContent = "Error loading data";
    if (els.help) els.help.textContent = "Could not parse pasta data on this page.";
    return;
  }

  // Updated naming to match your recategorization language
  const TYPE_LABELS = {
    strand: "Strand",
    tube: "Tube",
    ribbon: "Ribbon",
    sheet: "Sheet",
    short: "Short cut",
    stuffed: "Stuffed",
    soup: "Soup (Pastina)",
    ring: "Ring",
    dumpling: "Dumpling",
  };

  const TYPE_DESCS = {
    strand: "Long, thin noodles (round or slightly flattened).",
    tube: "Hollow pasta designed to hold sauce inside.",
    ribbon: "Long, flat strips like fettuccine-style cuts.",
    sheet: "Sheets used for layering or cutting (lasagna-style).",
    short: "Short shapes that scoop, trap, or cling to sauce.",
    stuffed: "Filled pasta (pockets, pillows, or sealed edges).",
    soup: "Tiny pasta made for spoons and brothy soups.",
    ring: "Rings that catch sauce in openings.",
    dumpling: "Pasta-like dumplings (often irregular or rustic).",
  };

  const QUESTION_DEFS = [
    {
      key: "type",
      title: "What general type is it?",
      help: "Start broad - this narrows the list quickly.",
      kind: "enum",
      values: Object.keys(TYPE_LABELS),
      label: (v) => TYPE_LABELS[v] || v,
      desc: (v) => TYPE_DESCS[v] || "",
      icon: (v) => identifyIconUrlFor(`${v}.png`),
    },
    {
      key: "hollow",
      title: "Is it hollow?",
      help: "Hollow pasta has a visible tube or cavity.",
      kind: "bool",
      descYes: "You can see a tube or opening through the shape.",
      descNo: "Solid pasta - no tube or cavity.",
    },
    {
      key: "ridged",
      title: "Does it have ridges?",
      help: "Ridges (rigate) help grip sauce.",
      kind: "bool",
      descYes: "Noticeable grooves or ridges on the surface.",
      descNo: "Mostly smooth surface.",
    },
    {
      key: "twisted",
      title: "Is it twisted?",
      help: "Twisted shapes include spirals and corkscrews.",
      kind: "bool",
      descYes: "Spiraled or corkscrew-like geometry.",
      descNo: "Not spiraled or twisted.",
    },
    {
      key: "curved",
      title: "Is it curved?",
      help: "Curved shapes include elbows, crescents, and arcs.",
      kind: "bool",
      descYes: "Bent or arced rather than straight.",
      descNo: "Straight rather than bent.",
    },
    {
      key: "size",
      title: "What size is it?",
      help: "If you’re unsure, pick “Not sure” - size is often the least reliable.",
      kind: "enum",
      values: ["tiny", "small", "medium", "large"],
      label: (v) => v,
      icon: (v) => identifyIconUrlFor(`size-${v}.png`),
    },
  ];

  const normalize = (v) => String(v || "").trim().toLowerCase();

  const initial = raw.map((r) => ({
    slug: r.slug,
    name: r.name,
    type: normalize(r.type),
    size: normalize(r.size),
    hollow: normalize(r.hollow),
    ridged: normalize(r.ridged),
    twisted: normalize(r.twisted),
    curved: normalize(r.curved),
    stuffed: normalize(r.stuffed),
    also: String(r.also || ""),
    thumb: String(r.thumb || ""),
  }));

  let working = initial.slice();
  let history = [];

  // Results panel behavior:
  // - "auto": show list automatically only when small
  // - "show": user expanded
  // - "hide": user collapsed
  let resultsPanelPreference = "auto";

  // Results list limiting
  let showAllResults = false;
  let resultsLimit = DEFAULT_RESULTS_LIMIT;

  // iOS scroll-jump prevention: only rebuild results DOM when the list or limit changes.
  let lastResultsKey = "";

  const sortWorking = () => {
    working.sort((a, b) =>
      String(a.name || "").localeCompare(String(b.name || ""), "en", { sensitivity: "base" })
    );
  };

  const resultsKey = () => {
    const slugs = working.map((x) => x.slug).slice().sort().join("|");
    return `${slugs}::${showAllResults ? "all" : resultsLimit}`;
  };

  const setText = (el, txt) => { if (el) el.textContent = txt; };

  const renderMatchesCount = () => {
    setText(els.count, `Matching: ${working.length}`);
  };

  const renderResultsList = () => {
    if (!els.resultsList) return;

    const key = resultsKey();
    if (key === lastResultsKey) {
      setText(els.resultsCount, `${working.length} match${working.length === 1 ? "" : "es"}`);
      return;
    }
    lastResultsKey = key;

    els.resultsList.innerHTML = "";

    const n = showAllResults ? working.length : Math.min(working.length, resultsLimit);

    for (const item of working.slice(0, n)) {
      const li = document.createElement("li");
      li.className = "result-card";

      const a = document.createElement("a");
      a.className = "result-link";
      a.href = `/pasta/${item.slug}/`;
      a.setAttribute("data-recent", "pasta");

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      const img = document.createElement("img");
      img.width = 56;
      img.height = 56;
      img.loading = "lazy";
      img.decoding = "async";
      img.alt = "";
      img.src = thumbUrlFor(item.thumb);

      thumb.appendChild(img);

      const body = document.createElement("div");
      body.className = "result-body";

      const titleRow = document.createElement("div");
      titleRow.className = "result-title-row";

      const strong = document.createElement("strong");
      strong.className = "result-name";
      strong.textContent = item.name;

      titleRow.appendChild(strong);
      body.appendChild(titleRow);

      a.appendChild(thumb);
      a.appendChild(body);
      li.appendChild(a);
      els.resultsList.appendChild(li);
    }

    // Optional "Show more" row when not showing all
    if (!showAllResults && working.length > resultsLimit) {
      const li = document.createElement("li");
      li.className = "result-card";

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn secondary";
      const remaining = working.length - resultsLimit;
      btn.textContent = `Show more (${Math.min(remaining, SHOW_MORE_STEP)})`;
      btn.addEventListener("click", () => {
        resultsLimit = Math.min(working.length, resultsLimit + SHOW_MORE_STEP);
        lastResultsKey = "";
        renderResultsList();
        syncToggleLabel();
      });

      li.appendChild(btn);
      els.resultsList.appendChild(li);
    }

    setText(els.resultsCount, `${working.length} match${working.length === 1 ? "" : "es"}`);
  };

  const syncToggleLabel = () => {
    if (!els.btnToggleResults) return;

    if (els.resultsCard.hidden) {
      els.btnToggleResults.textContent = "Show all";
      return;
    }

    els.btnToggleResults.textContent = showAllResults ? "Show fewer" : "Show all";
  };

  const showResultsPanel = (show) => {
    if (!els.resultsCard || !els.btnToggleResults) return;
    els.resultsCard.hidden = !show;
    els.btnToggleResults.hidden = false;
    syncToggleLabel();
  };

  const shouldShowResultsPanel = () => {
    if (resultsPanelPreference === "show") return true;
    if (resultsPanelPreference === "hide") return false;
    return working.length <= AUTO_SHOW_RESULTS_THRESHOLD;
  };

  const questionAlreadyAnswered = (key) => history.some((h) => h.key === key);

  const nextQuestion = () => {
    // Type always first
    if (!questionAlreadyAnswered("type")) return QUESTION_DEFS.find((q) => q.key === "type");

    const answered = new Set(history.map((h) => h.key));

    // Score using Gini impurity (higher => better splitter)
    const scoreQuestion = (key) => {
      const counts = new Map();

      for (const item of working) {
        const v = String(item[key] || "").trim();
        if (!v) continue; // ignore unknowns
        counts.set(v, (counts.get(v) || 0) + 1);
      }

      if (counts.size < 2) return 0;

      const total = Array.from(counts.values()).reduce((a, b) => a + b, 0);
      if (!total) return 0;

      let sumSq = 0;
      for (const c of counts.values()) {
        const p = c / total;
        sumSq += p * p;
      }
      return 1 - sumSq;
    };

    const preferredOrder = ["hollow", "ridged", "twisted", "curved", "size"];

    const candidates = [];
    for (const key of preferredOrder) {
      if (answered.has(key)) continue;

      // Keep size late stage
      if (key === "size" && working.length <= 25) continue;

      const q = QUESTION_DEFS.find((d) => d.key === key);
      if (!q) continue;

      const s = scoreQuestion(key);
      if (s > 0) candidates.push({ q, s });
    }

    if (!candidates.length) return null;

    candidates.sort((a, b) => b.s - a.s);
    return candidates[0].q;
  };

  const applyAnswer = (key, value) => {
    const prev = working;
    history.push({ key, value, prevWorking: prev });

    working = working.filter((item) => {
      const itemVal = item[key];
      if (!itemVal) return true;        // keep unknowns
      if (value === "__ns__") return true; // not sure keeps all
      return itemVal === value;
    });

    // Reset list limiting on each answer so UX stays predictable
    showAllResults = false;
    resultsLimit = DEFAULT_RESULTS_LIMIT;
    lastResultsKey = "";

    render();
  };

  const goBack = () => {
    if (!history.length) return;
    const last = history.pop();
    working = last.prevWorking || initial.slice();

    showAllResults = false;
    resultsLimit = DEFAULT_RESULTS_LIMIT;
    lastResultsKey = "";

    render();
  };

  const reset = () => {
    working = initial.slice();
    history = [];
    resultsPanelPreference = "auto";

    showAllResults = false;
    resultsLimit = DEFAULT_RESULTS_LIMIT;
    lastResultsKey = "";

    render();
  };

  // Count previews - mirrors applyAnswer() exactly
  const countAfterAnswer = (key, value) => {
    if (value === "__ns__") return working.length;

    let count = 0;
    for (const item of working) {
      const itemVal = item[key];

      if (!itemVal) { // unknown kept
        count++;
        continue;
      }

      if (itemVal === value) count++;
    }
    return count;
  };

  const renderAnswers = (q) => {
    if (!els.answers) return;

    // Expose kind/key to CSS for layout decisions
    els.answers.dataset.kind = q.kind || "";
    els.answers.dataset.key = q.key || "";

    els.answers.innerHTML = "";

    const addButton = (label, value, desc, iconUrl) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "identify-answer";
      btn.addEventListener("click", () => applyAnswer(q.key, value));

      // Leading icon area:
      // - bool uses glyphs (Y / N / ?)
      // - enum uses images
      if (q.kind === "bool") {
        const glyph = document.createElement("span");
        glyph.className = "identify-answer-glyph";
        glyph.textContent = (value === "yes") ? "Y" : (value === "no") ? "N" : "?";
        btn.appendChild(glyph);
      } else {
        const img = document.createElement("img");
        img.alt = "";
        img.loading = "lazy";
        img.decoding = "async";
        img.width = 56;
        img.height = 56;
        if (iconUrl) img.src = iconUrl;
        btn.appendChild(img);
      }

      const meta = document.createElement("div");
      meta.className = "identify-answer-meta";

      const t = document.createElement("div");
      t.className = "identify-answer-title";

      const projected = countAfterAnswer(q.key, value);
      t.textContent = `${label} (${projected})`;

      const d = document.createElement("div");
      d.className = "identify-answer-desc muted";
      d.textContent = desc || "";

      meta.appendChild(t);
      if (desc) meta.appendChild(d);

      btn.appendChild(meta);
      els.answers.appendChild(btn);
    };

    // Bool order: Yes, No, Not sure
    if (q.kind === "bool") {
      addButton("Yes", "yes", q.descYes || "", null);
      addButton("No", "no", q.descNo || "", null);
      addButton("Not sure", "__ns__", "Keep all possibilities.", null);
      return;
    }

    // Enum: sort by projected count DESC, tie => alpha
    const values = q.values || Object.keys(TYPE_LABELS);
    const rows = values.map((v) => ({
      v,
      label: q.label(v),
      desc: q.desc ? q.desc(v) : "",
      icon: q.icon ? q.icon(v) : null,
      projected: countAfterAnswer(q.key, v),
    }));

    rows.sort((a, b) => {
      if (b.projected !== a.projected) return b.projected - a.projected;
      return String(a.label).localeCompare(String(b.label), "en", { sensitivity: "base" });
    });

    for (const r of rows) addButton(r.label, r.v, r.desc, r.icon);

    addButton("Not sure", "__ns__", "Keep all possibilities.", null);
  };

  const render = () => {
    const q = nextQuestion();

    sortWorking();

    if (els.btnBack) els.btnBack.disabled = history.length === 0;

    // Exactly 1 match - confirmation state, no auto-redirect
    if (working.length === 1) {
      const only = working[0];

      setText(els.kicker, "Result");
      setText(els.title, "Is this your pasta?");
      setText(
        els.help,
        `We narrowed it down to 1 match: ${only.name}. Tap “View details” to confirm, or use Back / Reset to revise your answers.`
      );

      if (els.answers) {
        els.answers.dataset.kind = "single";
        els.answers.dataset.key = "single";
        els.answers.innerHTML = "";

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn";
        btn.textContent = "View details";
        btn.addEventListener("click", () => {
          window.location.href = `/pasta/${only.slug}/`;
        });

        els.answers.appendChild(btn);
      }

      renderMatchesCount();

      // Always show results in this state (so user can tap the card too)
      resultsPanelPreference = "show";
      showAllResults = true;

      showResultsPanel(true);
      renderResultsList();
      return;
    }

    // No more useful questions - show matches
    if (!q) {
      setText(els.kicker, "Done");
      setText(els.title, "Here are your matches");
      setText(els.help, "You can refine by restarting or tapping a match.");

      if (els.answers) {
        els.answers.dataset.kind = "done";
        els.answers.dataset.key = "done";
        els.answers.innerHTML = "";
      }

      resultsPanelPreference = "show";
      showResultsPanel(true);
      renderMatchesCount();
      renderResultsList();
      return;
    }

    // Normal flow
    setText(els.kicker, `Question ${history.length + 1}`);
    setText(els.title, q.title);
    setText(els.help, q.help || "");

    renderAnswers(q);
    renderMatchesCount();

    showResultsPanel(shouldShowResultsPanel());
    syncToggleLabel();
    renderResultsList();
  };

  // Controls
  if (els.btnBack) els.btnBack.addEventListener("click", goBack);
  if (els.btnReset) els.btnReset.addEventListener("click", reset);

  if (els.btnToggleResults) {
    els.btnToggleResults.addEventListener("click", () => {
      // If list hidden, show it (default limited)
      if (els.resultsCard.hidden) {
        resultsPanelPreference = "show";
        showAllResults = false;
        resultsLimit = DEFAULT_RESULTS_LIMIT;
        lastResultsKey = "";
        showResultsPanel(true);
        renderResultsList();
        return;
      }

      // If list visible, toggle show-all / show-fewer
      showAllResults = !showAllResults;
      if (!showAllResults) resultsLimit = DEFAULT_RESULTS_LIMIT;

      lastResultsKey = "";
      syncToggleLabel();
      renderResultsList();
    });
  }

  render();
})();
</script>
