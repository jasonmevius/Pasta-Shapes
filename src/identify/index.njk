---
title: Identify a pasta shape
layout: layout.njk
description: "Identify a pasta shape by answering a few quick questions. Mobile-friendly, one question at a time."
---

{# =============================================================================
  identify/index.njk
  ------------------------------------------------------------------------------
  PURPOSE
  - Identify pasta by narrowing down with sequential questions.
  - Mobile-first UI: big tap targets, one question at a time.
  - Show the user how each answer narrows the list using count previews.
  - When matches become small, show a live “Matches” table (helps confidence).
  - When exactly 1 match remains, DO NOT auto-redirect - show a confirmation
    state with a “View details” button so the user can verify or revise.

  IMPORTANT NOTES
  - Identify logic is embedded in this template (existing behavior).
  - No inline CSS - styling remains in /src/css/styles.css.

  CHANGE (RESULTS STANDARDIZATION)
  - Identify "Matches" now renders as an All-Pastas-style TABLE with:
      - Thumb (not sortable)
      - Name (sortable)
      - Category (sortable)
      - Synonyms (hidden on narrow screens via existing CSS rules)
============================================================================= #}

{% from "partials/pasta-results-table.njk" import pastaResultsTable %}

{# -----------------------------------------------------------------------------
  Build identifyData JSON in the template so JS has a compact dataset.
  NOTE: "category" is populated for the results table.
----------------------------------------------------------------------------- #}
{% set identifyData = [] %}
{% for item in pasta %}

  {% set thumbCandidate = (item.ThumbnailImage or "") | replace("<ImageKitPath>", "") | trim %}
  {% set thumbRaw = thumbCandidate if thumbCandidate else (item.Slug ~ ".png") %}

  {% set alsoRaw =
    item.SearchAliases
    or item.Aliases
    or item.Synonyms
    or item.Also
    or item.Misspellings
    or ""
  %}

  {# Category support across schema changes:
     - Prefer "Category" if present, otherwise "Type" (common in your CSV),
       otherwise fall back to blank. #}
  {% set categoryRaw =
    item.Category
    or item.Type
    or item.ShapeCategory
    or item.PastaCategory
    or ""
  %}

  {% set _ = identifyData.push({
    slug: item.Slug,
    name: item.ShapeName,
    category: categoryRaw,
    type: item.Type or "",
    size: item.SizeClass or "",
    hollow: item.IsHollow or "",
    ridged: item.IsRidged or "",
    twisted: item.IsTwisted or "",
    curved: item.IsCurved or "",
    stuffed: item.IsStuffed or "",
    also: alsoRaw,
    thumb: thumbRaw
  }) %}
{% endfor %}

<header class="stack tight">
  <h1 class="h1">Identify a pasta shape</h1>
  <p class="muted">Answer one question at a time. You can always tap “Not sure.”</p>
</header>

<section id="identify-app" class="identify">
  <div class="card identify-card">
    <div class="identify-question">
      <p class="identify-kicker muted" id="identify-kicker">Question</p>
      <h2 class="identify-title" id="identify-title">Loading…</h2>
      <p class="identify-help muted" id="identify-help"></p>
    </div>

    <div class="identify-answers" id="identify-answers" aria-live="polite"></div>

    <div class="identify-meta">
      <span class="muted" id="identify-count"></span>
    </div>
  </div>

  {# =============================================================================
    Matches (standardized table)
    - Uses the same table classes as All Pastas / Home results.
    - Sortable headers are wired via the embedded script below.
  ============================================================================= #}
  <div class="card identify-results" id="identify-results" hidden>
    <div class="results-head">
      <h2 class="h2">Matches</h2>
      <p class="muted" id="identify-results-count"></p>
    </div>

    {% call pastaResultsTable(
      "identify",
      "table-wrap table-wrap--results",
      "Identify matches table",
      "",
      "",
      "identify-results-table",
      "data-table data-table--results js-sortable-table",
      "Identify matches table",
      "",
      "identify-results-body"
    ) %}
      {# Rows rendered by JS #}
    {% endcall %}
  </div>

  <div class="identify-bottom-bar" role="navigation" aria-label="Identify controls">
    <button class="btn secondary" type="button" id="identify-back" disabled>Back</button>
    <button class="btn secondary" type="button" id="identify-reset">Reset</button>
    <button class="btn" type="button" id="identify-toggle-results" hidden>Show all</button>
  </div>
</section>

<script type="application/json" id="identify-data">
{{ identifyData | dump | safe }}
</script>

<script>
(function () {
  // ============================================================================
  // Identify logic (embedded)
  // ----------------------------------------------------------------------------
  // NOTE
  // - This script is intentionally embedded to keep Identify self-contained.
  // - It renders matches into an All-Pastas-style table with sortable headers.
  // - It sets window.__pastaIdentifyInit to prevent double-init if other scripts
  //   attempt to attach Identify behavior.
  // ============================================================================
  if (window.__pastaIdentifyInit) return;
  window.__pastaIdentifyInit = true;

  const $ = (sel, root = document) => root.querySelector(sel);

  const els = {
    app: $("#identify-app"),
    title: $("#identify-title"),
    kicker: $("#identify-kicker"),
    help: $("#identify-help"),
    answers: $("#identify-answers"),
    count: $("#identify-count"),

    resultsCard: $("#identify-results"),
    resultsCount: $("#identify-results-count"),

    resultsTable: $("#identify-results-table"),
    resultsBody: $("#identify-results-body"),

    btnBack: $("#identify-back"),
    btnReset: $("#identify-reset"),
    btnToggleResults: $("#identify-toggle-results"),

    dataScript: $("#identify-data"),
  };

  // ImageKit bases
  const IK_THUMBS_BASE = "https://ik.imagekit.io/mevius/pasta/thumbs/";
  const IK_IDENTIFY_BASE = "https://ik.imagekit.io/mevius/pasta/identify/";
  const FALLBACK_THUMB = "pending.png";

  // UX tuning
  const AUTO_SHOW_RESULTS_THRESHOLD = 10;

  // Results sizing
  const DEFAULT_RESULTS_LIMIT = 60;
  const SHOW_MORE_STEP = 60;

  // Sorting state for the results table
  let sortKey = "name";
  let sortDir = "ascending";

  const isUrl = (s) => /^https?:\/\//i.test(String(s || "").trim());

  const fileNameOnly = (s) => {
    const str = String(s || "").trim();
    if (!str) return "";
    const clean = str.split("#")[0].split("?")[0];
    const parts = clean.split("/");
    return parts[parts.length - 1] || "";
  };

  const thumbUrlFor = (thumbRaw) => {
    if (isUrl(thumbRaw)) return String(thumbRaw).trim();
    const fn = fileNameOnly(thumbRaw);
    return IK_THUMBS_BASE + (fn || FALLBACK_THUMB);
  };

  const identifyIconUrlFor = (file) => IK_IDENTIFY_BASE + file;

  const answerIconFor = (questionKey, value) => {
    if (value === "__ns__") return identifyIconUrlFor(`${questionKey}-notsure.png`);
    return identifyIconUrlFor(`${questionKey}-${value}.png`);
  };

  if (!els.app || !els.dataScript) return;

  let raw = [];
  try {
    raw = JSON.parse(els.dataScript.textContent || "[]");
  } catch (e) {
    console.error("Identify: failed to parse identify-data JSON", e);
    if (els.title) els.title.textContent = "Error loading data";
    if (els.help) els.help.textContent = "Could not parse pasta data on this page.";
    return;
  }

  const TYPE_LABELS = {
    strand: "Strand",
    tube: "Tube",
    ribbon: "Ribbon",
    sheet: "Sheet",
    short: "Short cut",
    stuffed: "Stuffed",
    soup: "Soup (Pastina)",
    ring: "Ring",
    dumpling: "Dumpling",
  };

  const TYPE_DESCS = {
    strand: "Long, thin noodles (round or slightly flattened).",
    tube: "Hollow pasta designed to hold sauce inside.",
    ribbon: "Long, flat strips like fettuccine-style cuts.",
    sheet: "Sheets used for layering or cutting (lasagna-style).",
    short: "Short shapes that scoop, trap, or cling to sauce.",
    stuffed: "Filled pasta (pockets, pillows, or sealed edges).",
    soup: "Tiny pasta made for spoons and brothy soups.",
    ring: "Rings that catch sauce in openings.",
    dumpling: "Pasta-like dumplings (often irregular or rustic).",
  };

  const normalize = (v) => String(v || "").trim().toLowerCase();

  // Canonical dataset (what Identify filters against)
  const initial = raw.map((r) => ({
    slug: r.slug,
    name: r.name,
    category: String(r.category || r.type || "").trim(),
    type: normalize(r.type),
    size: normalize(r.size),
    hollow: normalize(r.hollow),
    ridged: normalize(r.ridged),
    twisted: normalize(r.twisted),
    curved: normalize(r.curved),
    stuffed: normalize(r.stuffed),
    also: String(r.also || ""),
    thumb: String(r.thumb || ""),
  }));

  // Question definitions (same as before)
  const QUESTION_DEFS = [
    {
      key: "type",
      title: "What general type is it?",
      help: "Start broad - this narrows the list quickly.",
      kind: "enum",
      values: Object.keys(TYPE_LABELS),
      label: (v) => TYPE_LABELS[v] || v,
      desc: (v) => TYPE_DESCS[v] || "",
      icon: (v) => identifyIconUrlFor(`${v}.png`),
    },
    {
      key: "hollow",
      title: "Is it hollow?",
      help: "Hollow pasta has a visible tube or cavity.",
      kind: "bool",
      descYes: "You can see a tube or opening through the shape.",
      descNo: "Solid pasta - no tube or cavity.",
    },
    {
      key: "ridged",
      title: "Does it have ridges?",
      help: "Ridges (rigate) help grip sauce.",
      kind: "bool",
      descYes: "Noticeable grooves or ridges on the surface.",
      descNo: "Mostly smooth surface.",
    },
    {
      key: "twisted",
      title: "Is it twisted?",
      help: "Twisted shapes include spirals and corkscrews.",
      kind: "bool",
      descYes: "Spiraled or corkscrew-like geometry.",
      descNo: "Not spiraled or twisted.",
    },
    {
      key: "curved",
      title: "Is it curved?",
      help: "Curved shapes include elbows, crescents, and arcs.",
      kind: "bool",
      descYes: "Bent or arced rather than straight.",
      descNo: "Straight rather than bent.",
    },
    {
      key: "size",
      title: "What size is it?",
      help: "If you’re unsure, pick “Not sure” - size is often the least reliable.",
      kind: "enum",
      values: ["tiny", "small", "medium", "large"],
      label: (v) => v,
      icon: (v) => identifyIconUrlFor(`size-${v}.png`),
    },
  ];

  // Working state
  let working = initial.slice();
  let history = []; // [{ key, value, prevWorking }]
  let resultsPanelPreference = "auto"; // auto | show | hide
  let resultsLimit = DEFAULT_RESULTS_LIMIT;

  const setText = (el, txt) => { if (el) el.textContent = txt; };

  // Sorting
  function compare(a, b) {
    const aKey = (sortKey === "category" ? a.category : a.name) || "";
    const bKey = (sortKey === "category" ? b.category : b.name) || "";
    const cmp = String(aKey).localeCompare(String(bKey), "en", { sensitivity: "base" });
    return sortDir === "descending" ? -cmp : cmp;
  }

  function sortWorking() {
    working.sort(compare);
  }

  // Match count label
  function renderMatchesCount() {
    setText(els.count, `Matching: ${working.length}`);
  }

  // Show/hide results panel
  function showResultsPanel(show) {
    if (!els.resultsCard || !els.btnToggleResults) return;
    els.resultsCard.hidden = !show;
    els.btnToggleResults.hidden = false;

    if (!show) {
      els.btnToggleResults.textContent = "Show all";
    } else {
      els.btnToggleResults.textContent =
        resultsLimit >= working.length ? "Hide list" : "Show all";
    }
  }

  function shouldShowResultsPanel() {
    if (resultsPanelPreference === "show") return true;
    if (resultsPanelPreference === "hide") return false;
    return working.length <= AUTO_SHOW_RESULTS_THRESHOLD;
  }

  // Render results into the table body
  function renderResultsTable() {
    if (!els.resultsBody) return;

    els.resultsBody.innerHTML = "";

    const n = Math.min(working.length, resultsLimit);
    const slice = working.slice(0, n);

    for (const item of slice) {
      const tr = document.createElement("tr");
      tr.className = "data-row";
      tr.setAttribute("data-slug", item.slug);
      tr.setAttribute("data-name", item.name);
      tr.setAttribute("data-category", item.category || "");

      // Thumb cell
      const tdThumb = document.createElement("td");
      tdThumb.className = "data-table__thumb";

      const spanThumb = document.createElement("span");
      spanThumb.className = "thumb";
      spanThumb.setAttribute("aria-hidden", "true");

      const img = document.createElement("img");
      img.width = 56;
      img.height = 56;
      img.loading = "lazy";
      img.decoding = "async";
      img.alt = "";
      img.src = thumbUrlFor(item.thumb) + "?tr=w-56,h-56,f-auto,q-50";

      spanThumb.appendChild(img);
      tdThumb.appendChild(spanThumb);

      // Name (row header cell)
      const thName = document.createElement("th");
      thName.scope = "row";
      thName.className = "data-table__name";

      const a = document.createElement("a");
      a.href = `/pasta/${item.slug}/`;
      a.textContent = item.name;
      thName.appendChild(a);

      // Category
      const tdCat = document.createElement("td");
      tdCat.className = "cell-category";
      tdCat.textContent = item.category || "";

      // Synonyms
      const tdSyn = document.createElement("td");
      tdSyn.className = "cell-synonyms";
      tdSyn.textContent = item.also || "";

      tr.appendChild(tdThumb);
      tr.appendChild(thName);
      tr.appendChild(tdCat);
      tr.appendChild(tdSyn);

      els.resultsBody.appendChild(tr);
    }

    setText(els.resultsCount, `${working.length} match${working.length === 1 ? "" : "es"}`);

    // Show-more row (spans all columns)
    if (!els.resultsCard.hidden && resultsLimit < working.length) {
      const trMore = document.createElement("tr");

      const tdMore = document.createElement("td");
      tdMore.colSpan = 4;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn secondary";
      btn.textContent = `Show more (${Math.min(working.length - resultsLimit, SHOW_MORE_STEP)})`;
      btn.addEventListener("click", () => {
        resultsLimit = Math.min(working.length, resultsLimit + SHOW_MORE_STEP);
        renderResultsTable();
        syncToggleLabel();
      });

      tdMore.appendChild(btn);
      trMore.appendChild(tdMore);
      els.resultsBody.appendChild(trMore);
    }
  }

  // Sort header wiring (local to Identify table)
  if (els.resultsBody) {
    els.resultsBody.addEventListener("click", (e) => {
      const interactive = e.target.closest("a, button, input, select, textarea, label");
      if (interactive) return;

      const row = e.target.closest("tr.data-row[data-slug]");
      if (!row || !els.resultsBody.contains(row)) return;

      const slug = String(row.getAttribute("data-slug") || "").trim();
      if (!slug) return;
      window.location.href = `/pasta/${slug}/`;
    });
  }

  function initTableSorting() {
    if (!els.resultsTable) return;

    const headers = Array.from(els.resultsTable.querySelectorAll("thead th[data-sort]"));
    if (!headers.length) return;

    function setSortState(activeKey, dir) {
      for (const th of headers) {
        const key = th.getAttribute("data-sort");
        th.setAttribute("aria-sort", key === activeKey ? dir : "none");
      }
      sortKey = activeKey;
      sortDir = dir;
    }

    function toggle(th) {
      const key = th.getAttribute("data-sort");
      const cur = th.getAttribute("aria-sort") || "none";

      let next = "ascending";
      if (cur === "ascending") next = "descending";
      if (cur === "descending") next = "ascending";

      setSortState(key, next);
      sortWorking();
      renderResultsTable();
    }

    for (const th of headers) {
      th.addEventListener("click", () => toggle(th));
      th.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          toggle(th);
        }
      });
    }

    // Ensure initial state
    setSortState("name", "ascending");
  }

  function syncToggleLabel() {
    if (!els.btnToggleResults || !els.resultsCard) return;
    if (els.resultsCard.hidden) {
      els.btnToggleResults.textContent = "Show all";
      return;
    }
    els.btnToggleResults.textContent =
      resultsLimit >= working.length ? "Hide list" : "Show all";
  }

  // Identify filtering helpers
  function questionAlreadyAnswered(key) {
    return history.some((h) => h.key === key);
  }

  function nextQuestion() {
    if (!questionAlreadyAnswered("type")) return QUESTION_DEFS.find((q) => q.key === "type");
    for (const q of QUESTION_DEFS) if (!questionAlreadyAnswered(q.key)) return q;
    return null;
  }

  function applyFilter(key, value) {
    const prev = working.slice();

    const normalizeBool = (v) => {
      if (v === "__ns__") return "__ns__";
      return String(v || "").toLowerCase();
    };

    working = working.filter((p) => {
      if (value === "__ns__") return true;
      const v = normalizeBool(value);
      const pv = normalizeBool(p[key]);
      return pv === v;
    });

    history.push({ key, value, prevWorking: prev });
    sortWorking();
  }

  function goBack() {
    const last = history.pop();
    if (!last) return;
    working = last.prevWorking.slice();
    sortWorking();
  }

  function resetAll() {
    history = [];
    working = initial.slice();
    resultsLimit = DEFAULT_RESULTS_LIMIT;
    resultsPanelPreference = "auto";
    sortWorking();
  }

  function renderQuestion() {
    const q = nextQuestion();

    renderMatchesCount();

    if (!q) {
      setText(els.title, "Done");
      setText(els.kicker, "Here are your matches.");
      setText(els.help, "Use Back to change your last answer, or Reset to start over.");
      if (els.answers) els.answers.innerHTML = "";
      showResultsPanel(true);
      renderResultsTable();
      syncToggleLabel();
      return;
    }

    setText(els.title, q.title);
    setText(els.kicker, `Step ${history.length + 1}`);
    setText(els.help, q.help || "");

    if (els.btnBack) els.btnBack.disabled = history.length === 0;
    if (els.btnReset) els.btnReset.hidden = history.length === 0;

    showResultsPanel(shouldShowResultsPanel());
    renderResultsTable();
    syncToggleLabel();

    if (!els.answers) return;
    els.answers.innerHTML = "";
    els.answers.setAttribute("data-kind", q.kind);
    els.answers.setAttribute("data-key", q.key);

    const makeAnswer = (value, label, desc, iconUrl) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "identify-answer";

      // Bool questions use glyphs (Y / N / ?)
      if (q.kind === "bool") {
        const glyph = document.createElement("span");
        glyph.className = "identify-answer-glyph";
        glyph.textContent = value === "yes" ? "Y" : value === "no" ? "N" : "?";
        btn.appendChild(glyph);
      } else {
        const img = document.createElement("img");
        img.alt = "";
        img.loading = "lazy";
        img.decoding = "async";
        img.width = 56;
        img.height = 56;
        img.src = iconUrl || "";
        btn.appendChild(img);
      }

      const meta = document.createElement("span");
      meta.className = "identify-answer-meta";

      const title = document.createElement("span");
      title.className = "identify-answer-title";
      title.textContent = label;
      meta.appendChild(title);

      if (desc) {
        const d = document.createElement("span");
        d.className = "identify-answer-desc";
        d.textContent = desc;
        meta.appendChild(d);
      }

      btn.appendChild(meta);

      btn.addEventListener("click", () => {
        applyFilter(q.key, value);
        renderQuestion();
      });

      return btn;
    };

    if (q.kind === "enum") {
      for (const v of q.values) {
        els.answers.appendChild(
          makeAnswer(
            v,
            q.label ? q.label(v) : String(v),
            q.desc ? q.desc(v) : "",
            q.icon ? q.icon(v) : ""
          )
        );
      }

      els.answers.appendChild(
        makeAnswer("__ns__", "Not sure", "Skip this question.", q.icon ? q.icon("__ns__") : "")
      );
    }

    if (q.kind === "bool") {
      els.answers.appendChild(makeAnswer("yes", "Yes", q.descYes || "", answerIconFor(q.key, "yes")));
      els.answers.appendChild(makeAnswer("no", "No", q.descNo || "", answerIconFor(q.key, "no")));
      els.answers.appendChild(makeAnswer("__ns__", "Not sure", "Skip this question.", answerIconFor(q.key, "__ns__")));
    }

    if (q.kind === "single") {
      els.answers.appendChild(makeAnswer("__ns__", "Continue", "", ""));
    }
  }

  // Controls
  if (els.btnBack) {
    els.btnBack.addEventListener("click", () => {
      goBack();
      renderQuestion();
    });
  }

  if (els.btnReset) {
    els.btnReset.addEventListener("click", () => {
      resetAll();
      renderQuestion();
    });
  }

  if (els.btnToggleResults) {
    els.btnToggleResults.addEventListener("click", () => {
      const currentlyHidden = Boolean(els.resultsCard && els.resultsCard.hidden);

      if (currentlyHidden) {
        resultsPanelPreference = "show";
        if (els.resultsCard) els.resultsCard.hidden = false;

        // When user explicitly requests the list, show everything.
        resultsLimit = working.length;
        renderResultsTable();
        syncToggleLabel();
      } else {
        resultsPanelPreference = "hide";
        if (els.resultsCard) els.resultsCard.hidden = true;
        syncToggleLabel();
      }
    });
  }

  // Init
  sortWorking();
  initTableSorting();
  renderQuestion();
})();
</script>
