---
title: Identify a pasta shape
layout: layout.njk
description: "Identify a pasta shape by answering a few quick questions. Search-first design, mobile-friendly."
---

{% set identifyData = [] %}
{% for item in pasta %}

  {# Thumbnail normalization you already use #}
  {% set thumb = (item.ThumbnailImage or "") | replace("<ImageKitPath>", "") %}

  {# Try common alias column names (use whichever exists in your CSV) #}
  {% set alsoRaw =
    item.SearchAliases
    or item.Aliases
    or item.Synonyms
    or item.Also
    or item.Misspellings
    or ""
  %}

  {% set _ = identifyData.push({
    slug: item.Slug,
    name: item.ShapeName,
    type: item.Type or "",
    size: item.SizeClass or "",
    hollow: item.IsHollow or "",
    ridged: item.IsRidged or "",
    twisted: item.IsTwisted or "",
    curved: item.IsCurved or "",
    stuffed: item.IsStuffed or "",
    also: alsoRaw,
    thumb: thumb
  }) %}
{% endfor %}

<nav class="breadcrumbs">
  <a href="/">← Back to search</a>
</nav>

<header class="stack tight">
  <h1 class="h1">Identify a pasta shape</h1>
  <p class="muted">Answer one question at a time. You can always tap “Not sure.”</p>
</header>

<style>
  .identify .identify-card { display: block; }
  .identify .identify-question { margin-bottom: 12px; }
  .identify .identify-kicker { margin: 0 0 6px; }
  .identify .identify-title { margin: 0 0 6px; }
  .identify .identify-help { margin: 0 0 10px; }

  .identify .identify-answers { display: grid; gap: 10px; }
  @media (min-width: 720px) {
    .identify .identify-answers { grid-template-columns: repeat(2, minmax(0, 1fr)); }
  }

  /* Answer options as “search-like” cards */
  .identify .option-card {
    width: 100%;
    text-align: left;
    border: 1px solid rgba(0,0,0,0.12);
    border-radius: 12px;
    padding: 10px;
    background: #fff;
    display: grid;
    grid-template-columns: 44px 1fr;
    gap: 10px;
    align-items: center;
    cursor: pointer;
  }
  .identify .option-card:hover { box-shadow: 0 6px 18px rgba(0,0,0,0.08); }
  .identify .option-thumb {
    width: 44px;
    height: 44px;
    border-radius: 10px;
    object-fit: contain;
    background: rgba(0,0,0,0.03);
  }
  .identify .option-name { font-weight: 650; line-height: 1.1; margin: 0; }
  .identify .option-desc { margin: 4px 0 0; font-size: 0.95rem; line-height: 1.25; opacity: 0.75; }

  .identify .identify-meta { margin-top: 10px; }

  /* Results: echo Search page hierarchy */
  .identify .identify-results { margin-top: 14px; }
  .identify .results-head { display: flex; align-items: baseline; justify-content: space-between; gap: 12px; }
  .identify .results-list { list-style: none; padding: 0; margin: 10px 0 0; display: grid; gap: 10px; }

  .identify .result-item { border: 1px solid rgba(0,0,0,0.12); border-radius: 12px; background: #fff; }
  .identify .result-link {
    display: grid;
    grid-template-columns: 44px 1fr;
    gap: 10px;
    align-items: center;
    padding: 10px;
    text-decoration: none;
    color: inherit;
  }
  .identify .result-link:hover { box-shadow: 0 6px 18px rgba(0,0,0,0.08); }

  .identify .result-thumb {
    width: 44px;
    height: 44px;
    border-radius: 10px;
    object-fit: cover;
    background: rgba(0,0,0,0.03);
  }

  .identify .result-text { min-width: 0; }
  .identify .result-name { font-weight: 700; margin: 0; line-height: 1.15; }
  .identify .result-type,
  .identify .result-meta,
  .identify .result-also { margin: 3px 0 0; font-size: 0.95rem; opacity: 0.75; }
  .identify .result-type { margin-top: 4px; }

  .identify .identify-bottom-bar { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
</style>

<section id="identify-app" class="identify">
  <div class="card identify-card">
    <div class="identify-question">
      <p class="identify-kicker muted" id="identify-kicker">Question</p>
      <h2 class="identify-title" id="identify-title">Loading…</h2>
      <p class="identify-help muted" id="identify-help"></p>
    </div>

    <div class="identify-answers" id="identify-answers" aria-live="polite"></div>

    <div class="identify-meta">
      <span class="muted" id="identify-count"></span>
    </div>
  </div>

  <div class="card identify-results" id="identify-results" hidden>
    <div class="results-head">
      <h2 class="h2">Matches</h2>
      <p class="muted" id="identify-results-count"></p>
    </div>
    <ul class="results-list" id="identify-results-list"></ul>
  </div>

  <div class="identify-bottom-bar" role="navigation" aria-label="Identify controls">
    <button class="btn secondary" type="button" id="identify-back" disabled>Back</button>
    <button class="btn secondary" type="button" id="identify-reset">Reset</button>
    <button class="btn" type="button" id="identify-toggle-results" hidden>Show all</button>
  </div>
</section>

<script type="application/json" id="identify-data">
{{ identifyData | dump | safe }}
</script>

<script>
(function () {
  if (window.__pastaIdentifyInit) return;
  window.__pastaIdentifyInit = true;

  const $ = (sel, root = document) => root.querySelector(sel);

  const els = {
    app: $("#identify-app"),
    title: $("#identify-title"),
    kicker: $("#identify-kicker"),
    help: $("#identify-help"),
    answers: $("#identify-answers"),
    count: $("#identify-count"),
    resultsCard: $("#identify-results"),
    resultsCount: $("#identify-results-count"),
    resultsList: $("#identify-results-list"),
    btnBack: $("#identify-back"),
    btnReset: $("#identify-reset"),
    btnToggleResults: $("#identify-toggle-results"),
    dataScript: $("#identify-data"),
  };

  if (!els.app || !els.dataScript) return;

  let raw = [];
  try {
    raw = JSON.parse(els.dataScript.textContent || "[]");
  } catch (e) {
    console.error("Identify: failed to parse identify-data JSON", e);
    els.title.textContent = "Error loading data";
    els.help.textContent = "Could not parse pasta data on this page.";
    return;
  }

  const TYPE_LABELS = {
    strand: "Strand",
    tube: "Tube",
    ribbon: "Ribbon",
    sheet: "Sheet",
    short: "Short cut",
    stuffed: "Stuffed",
    soup: "Soup / pastina",
    ring: "Ring / wheel",
    dumpling: "Dumpling / pasta-like",
  };

  const TYPE_DESCS = {
    strand: "Long, thin noodles (round or slightly flattened).",
    tube: "Hollow pasta designed to hold sauce inside.",
    ribbon: "Long, flat strips like fettuccine-style cuts.",
    sheet: "Sheets used for layering or cutting (lasagna-style).",
    short: "Short shapes that scoop, trap, or cling to sauce.",
    stuffed: "Filled pasta (pockets, pillows, or sealed edges).",
    soup: "Tiny pasta made for spoons and brothy soups.",
    ring: "Rings and wheels that catch sauce in openings.",
    dumpling: "Pasta-like dumplings (often irregular or rustic).",
  };

  const QUESTION_DEFS = [
    {
      key: "type",
      title: "What general type is it?",
      help: "Start broad - this narrows the list quickly.",
      kind: "enum",
      label: (v) => TYPE_LABELS[v] || v,
      desc: (v) => TYPE_DESCS[v] || "",
      icon: (v) => `/img/identify/${v}.png`,
    },
    {
      key: "stuffed",
      title: "Is it stuffed?",
      help: "Stuffed pasta includes filled shapes like ravioli-type forms.",
      kind: "bool",
      descYes: "There’s a filling inside (cheese, meat, etc.).",
      descNo: "No filling - it’s just pasta dough.",
    },
    {
      key: "hollow",
      title: "Is it hollow?",
      help: "Hollow pasta has a visible tube or cavity.",
      kind: "bool",
      descYes: "You can see a tube or opening through the shape.",
      descNo: "Solid pasta - no tube or cavity.",
    },
    {
      key: "ridged",
      title: "Does it have ridges?",
      help: "Ridges (rigate) help grip sauce.",
      kind: "bool",
      descYes: "Noticeable grooves or ridges on the surface.",
      descNo: "Mostly smooth surface.",
    },
    {
      key: "twisted",
      title: "Is it twisted?",
      help: "Twisted shapes include spirals and corkscrews.",
      kind: "bool",
      descYes: "Spiraled or corkscrew-like geometry.",
      descNo: "Not spiraled or twisted.",
    },
    {
      key: "curved",
      title: "Is it curved?",
      help: "Curved shapes include elbows, crescents, and arcs.",
      kind: "bool",
      descYes: "Bent or arced rather than straight.",
      descNo: "Mostly straight (or not defined by a curve).",
    },
    {
      key: "size",
      title: "What size class is it?",
      help: "Use size once you’ve narrowed the shape family.",
      kind: "enum",
      label: (v) => v,
      desc: (v) => `Choose this if the pasta feels like “${v}”.`,
      icon: (v) => `/img/identify/size.png`,
      deferUntilCountLTE: 25,
    },
  ];

  const normBool = (v) => {
    const s = String(v || "").trim().toLowerCase();
    if (!s) return "";
    if (s === "yes" || s === "y" || s === "true" || s === "1") return "yes";
    if (s === "no" || s === "n" || s === "false" || s === "0") return "no";
    return "";
  };

  const normEnum = (v) => String(v || "").trim().toLowerCase();

  const normAlso = (v) => {
    const s = String(v || "").trim();
    if (!s) return "";
    // If your aliases are comma-separated already, keep them. If they’re pipe-separated, normalize to comma.
    return s.replace(/\s*\|\s*/g, ", ").replace(/\s*,\s*/g, ", ").trim();
  };

  const normSizeForDisplay = (v) => {
    const s = String(v || "").trim();
    return s ? s.toLowerCase() : "";
  };

  const normalized = raw.map((p) => ({
    slug: p.slug,
    name: p.name,
    thumb: p.thumb || "",
    type: normEnum(p.type),
    size: String(p.size || "").trim(),
    hollow: normBool(p.hollow),
    ridged: normBool(p.ridged),
    twisted: normBool(p.twisted),
    curved: normBool(p.curved),
    stuffed: normBool(p.stuffed),
    also: normAlso(p.also),
  }));

  const state = {
    all: normalized,
    candidates: normalized.slice(),
    answers: {},
    history: [],
    currentKey: null,
    showAllResults: false, // Top 10 by default
  };

  const snapshot = () => ({
    candidates: state.candidates.slice(),
    answers: { ...state.answers },
    currentKey: state.currentKey,
    showAllResults: state.showAllResults,
  });

  const restore = (snap) => {
    state.candidates = snap.candidates.slice();
    state.answers = { ...snap.answers };
    state.currentKey = snap.currentKey;
    state.showAllResults = snap.showAllResults;
  };

  function uniqueValues(key, items) {
    const set = new Set();
    for (const it of items) {
      const v = it[key];
      if (v !== undefined && v !== null && String(v).trim() !== "") set.add(String(v));
    }
    return Array.from(set);
  }

  function scoreQuestion(key, items) {
    const total = items.length || 1;
    const counts = new Map();
    let blanks = 0;

    for (const it of items) {
      const v = (it[key] ?? "");
      const s = String(v).trim();
      if (!s) { blanks += 1; continue; }
      counts.set(s, (counts.get(s) || 0) + 1);
    }

    const nonBlank = total - blanks;
    if (nonBlank <= 1) return -1;

    let gini = 1;
    for (const c of counts.values()) {
      const p = c / nonBlank;
      gini -= p * p;
    }

    const blankPenalty = blanks / total;
    return gini - (0.35 * blankPenalty);
  }

  function nextQuestionKey() {
    if (state.answers.type === undefined) return "type";

    const remaining = state.candidates.length;

    const eligible = QUESTION_DEFS
      .filter((q) => q.key !== "type")
      .filter((q) => state.answers[q.key] === undefined)
      .filter((q) => {
        if (q.key === "size" && q.deferUntilCountLTE && remaining > q.deferUntilCountLTE) return false;
        const vals = uniqueValues(q.key, state.candidates);
        return vals.length >= 2;
      });

    if (!eligible.length) {
      if (state.answers.size === undefined) {
        const vals = uniqueValues("size", state.candidates);
        if (vals.length >= 2) return "size";
      }
      return null;
    }

    let best = eligible[0];
    let bestScore = -999;
    for (const q of eligible) {
      const s = scoreQuestion(q.key, state.candidates);
      if (s > bestScore) { bestScore = s; best = q; }
    }
    return best.key;
  }

  function getQuestionDef(key) {
    return QUESTION_DEFS.find((q) => q.key === key) || null;
  }

  function optionMeta(q, value) {
    const notSure = value === "__ns__";
    if (notSure) {
      return {
        icon: "/img/identify/not-sure.png",
        name: "Not sure",
        desc: "Skip this question and keep narrowing with the next best one.",
      };
    }

    if (q.kind === "bool") {
      const yes = value === "yes";
      return {
        icon: yes ? "/img/identify/yes.png" : "/img/identify/no.png",
        name: yes ? "Yes" : "No",
        desc: yes ? (q.descYes || "") : (q.descNo || ""),
      };
    }

    const label = q.label ? q.label(value) : String(value);
    const desc = q.desc ? q.desc(value) : "";
    const icon = q.icon ? q.icon(value) : "/img/identify/option.png";
    return { icon, name: label, desc };
  }

  function buildOptions(q, items) {
    if (q.kind === "bool") {
      return [{ value: "yes" }, { value: "no" }, { value: "__ns__" }];
    }

    const vals = uniqueValues(q.key, items);

    if (q.key === "type") {
      const preferredOrder = ["strand","tube","ribbon","sheet","short","stuffed","soup","ring","dumpling"];
      vals.sort((a,b) => preferredOrder.indexOf(a) - preferredOrder.indexOf(b));
      return vals.map((v) => ({ value: v })).concat([{ value: "__ns__" }]);
    }

    if (q.key === "size") {
      const order = ["Pastina","Tiny","Small","Medium","Large","Extra large","Jumbo"];
      vals.sort((a,b) => order.indexOf(a) - order.indexOf(b));
      return vals.map((v) => ({ value: v })).concat([{ value: "__ns__" }]);
    }

    vals.sort((a,b) => String(a).localeCompare(String(b)));
    return vals.map((v) => ({ value: v })).concat([{ value: "__ns__" }]);
  }

  function applyAnswer(key, value) {
    state.history.push(snapshot());

    const q = getQuestionDef(key);

    if (value === "__ns__") {
      state.answers[key] = null;
    } else {
      state.answers[key] = value;

      if (key === "type") {
        state.candidates = state.candidates.filter((p) => p.type === value);
      } else if (q && q.kind === "bool") {
        state.candidates = state.candidates.filter((p) => p[key] === value);
      } else {
        state.candidates = state.candidates.filter((p) => String(p[key] || "") === String(value));
      }
    }

    state.currentKey = nextQuestionKey();
    if (state.candidates.length < state.all.length) state.showAllResults = false;
    render();
  }

  function resetAll() {
    state.candidates = state.all.slice();
    state.answers = {};
    state.history = [];
    state.currentKey = nextQuestionKey();
    state.showAllResults = false;
    render();
  }

  function goBack() {
    const prev = state.history.pop();
    if (!prev) return;
    restore(prev);
    render();
  }

  function renderAnswers(q) {
    els.answers.innerHTML = "";
    const options = buildOptions(q, state.candidates);

    for (const opt of options) {
      const meta = optionMeta(q, opt.value);

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "option-card";
      btn.addEventListener("click", () => applyAnswer(q.key, opt.value));

      const img = document.createElement("img");
      img.className = "option-thumb";
      img.loading = "lazy";
      img.decoding = "async";
      img.alt = "";
      img.src = meta.icon;

      const wrap = document.createElement("div");

      const name = document.createElement("p");
      name.className = "option-name";
      name.textContent = meta.name;

      const desc = document.createElement("p");
      desc.className = "option-desc";
      desc.textContent = meta.desc;

      wrap.appendChild(name);
      wrap.appendChild(desc);

      btn.appendChild(img);
      btn.appendChild(wrap);

      els.answers.appendChild(btn);
    }
  }

  function renderCount() {
    const n = state.candidates.length;
    els.count.textContent = (n === 1) ? "1 possible match" : `${n} possible matches`;
  }

  function shouldShowResults() {
    return state.candidates.length < state.all.length;
  }

  function typeLabelFor(p) {
    return TYPE_LABELS[p.type] || (p.type ? p.type : "");
  }

  function buildMetaLine(p) {
    // Match your Search pattern: "medium , hollow"
    const bits = [];

    const size = normSizeForDisplay(p.size);
    if (size) bits.push(size);

    // Keep these as simple “tags” like Search
    if (p.hollow === "yes") bits.push("hollow");
    if (p.ridged === "yes") bits.push("ridged");
    if (p.twisted === "yes") bits.push("twisted");
    if (p.curved === "yes") bits.push("curved");
    if (p.stuffed === "yes") bits.push("stuffed");

    return bits.join(" , ");
  }

  function renderResults() {
    const total = state.candidates.length;
    const limit = state.showAllResults ? total : 10;
    const list = state.candidates.slice(0, limit);

    els.resultsCount.textContent = (total === 1) ? "1 match" : `${total} matches`;
    els.resultsList.innerHTML = "";

    for (const p of list) {
      const li = document.createElement("li");
      li.className = "result-item";

      const a = document.createElement("a");
      a.href = `/pasta/${p.slug}/`;
      a.className = "result-link";

      if (p.thumb) {
        const img = document.createElement("img");
        img.loading = "lazy";
        img.decoding = "async";
        img.alt = "";
        img.className = "result-thumb";
        img.src = p.thumb;
        a.appendChild(img);
      } else {
        const ph = document.createElement("div");
        ph.className = "result-thumb";
        a.appendChild(ph);
      }

      const text = document.createElement("div");
      text.className = "result-text";

      // Line 1: Name (bold)
      const name = document.createElement("p");
      name.className = "result-name";
      name.textContent = p.name;

      // Line 2: Type
      const type = document.createElement("p");
      type.className = "result-type";
      type.textContent = typeLabelFor(p);

      // Line 3: Meta (size + flags)
      const metaLine = buildMetaLine(p);
      const meta = document.createElement("p");
      meta.className = "result-meta";
      meta.textContent = metaLine;

      text.appendChild(name);
      if (type.textContent) text.appendChild(type);
      if (metaLine) text.appendChild(meta);

      // Line 4: Also (aliases)
      if (p.also) {
        const also = document.createElement("p");
        also.className = "result-also";
        also.textContent = `Also: ${p.also}`;
        text.appendChild(also);
      }

      a.appendChild(text);
      li.appendChild(a);
      els.resultsList.appendChild(li);
    }

    if (total > 10) {
      els.btnToggleResults.hidden = false;
      if (state.showAllResults) {
        els.btnToggleResults.textContent = "Show top 10";
      } else {
        const more = total - 10;
        els.btnToggleResults.textContent = `Show all ${total} matches (${more} more)`;
      }
    } else {
      els.btnToggleResults.hidden = true;
    }
  }

  function render() {
    els.btnBack.disabled = state.history.length === 0;

    if (!state.currentKey) {
      els.kicker.textContent = "Done";
      els.title.textContent = "Review your matches";
      els.help.textContent = "If you still have too many, use Back and pick a different answer.";
      els.answers.innerHTML = "";
      renderCount();
    } else {
      const q = getQuestionDef(state.currentKey);
      els.kicker.textContent = "Question";
      els.title.textContent = q ? q.title : "Question";
      els.help.textContent = q ? q.help : "";
      renderAnswers(q);
      renderCount();
    }

    const show = shouldShowResults();
    els.resultsCard.hidden = !show;
    if (show) renderResults();
  }

  els.btnReset.addEventListener("click", resetAll);
  els.btnBack.addEventListener("click", goBack);
  els.btnToggleResults.addEventListener("click", () => {
    state.showAllResults = !state.showAllResults;
    render();
  });

  state.currentKey = nextQuestionKey();
  render();
})();
</script>
