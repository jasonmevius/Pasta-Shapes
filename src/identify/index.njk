---
title: Identify a pasta shape
layout: layout.njk
description: "Identify a pasta shape by answering a few quick questions. Mobile-friendly, one question at a time."
---

{# =============================================================================
  identify/index.njk
  ------------------------------------------------------------------------------
  PURPOSE
  - Identify pasta by narrowing down with sequential questions.
  - Mobile-first UI: big tap targets, one question at a time.
  - Show the user how each answer narrows the list using count previews.
  - When matches become small, show a live “Matches” table (helps confidence).
  - When exactly 1 match remains, DO NOT auto-redirect - show a confirmation
    state with a “View details” button so the user can verify or revise.

  IMPORTANT NOTES
  - Identify logic is embedded in this template (existing behavior).
  - No inline CSS - styling remains in /src/css/styles.css.

  CHANGE (RESULTS STANDARDIZATION)
  - Identify "Matches" now renders as an All-Pastas-style TABLE with:
      - Thumb (not sortable)
      - Name (sortable)
      - Category (sortable)
      - Synonyms (hidden on narrow screens via existing CSS rules)
============================================================================= #}

{% from "partials/pasta-results-table.njk" import pastaResultsTable %}

{# -----------------------------------------------------------------------------
  Build identifyData JSON in the template so JS has a compact dataset.
  NOTE: "category" is populated for the results table.
----------------------------------------------------------------------------- #}
{% set identifyData = [] %}
{% for item in pasta %}

  {% set thumbCandidate = (item.ThumbnailImage or "") | replace("<ImageKitPath>", "") | trim %}
  {% set thumbRaw = thumbCandidate if thumbCandidate else (item.Slug ~ ".png") %}

  {% set alsoRaw =
    item.SearchAliases
    or item.Aliases
    or item.Synonyms
    or item.Also
    or item.Misspellings
    or ""
  %}

  {# Category support across schema changes:
     - Prefer "Category" if present, otherwise "Type" (common in your CSV),
       otherwise fall back to blank. #}
  {% set categoryRaw =
    item.Category
    or item.Type
    or item.ShapeCategory
    or item.PastaCategory
    or ""
  %}

  {% set _ = identifyData.push({
    slug: item.Slug,
    name: item.ShapeName,
    category: categoryRaw,
    type: item.Type or "",
    size: item.SizeClass or "",

    hollow: item.IsHollow or "",
    ridged: item.IsRidged or "",
    twisted: item.IsTwisted or "",
    curved: item.IsCurved or "",
    stuffed: item.IsStuffed or "",

    crossSection: item.CrossSection or item.CrossSectionShape or "",
    cutStyle: item.CutStyle or "",
    concave: item.IsConcave or "",
    ruffles: item.HasRuffles or item.IsRuffled or "",
    pastina: item.IsPastina or "",

    also: alsoRaw,
    thumb: thumbRaw
  }) %}
{% endfor %}

<header class="stack tight">
  <h1 class="h1">Identify a pasta shape</h1>
  <p class="muted">Answer one question at a time. You can always tap “Not sure.”</p>
</header>

<section id="identify-app" class="identify">
  <div class="card identify-card">
    <div class="identify-question">
      <p class="identify-kicker muted" id="identify-kicker">Question</p>
      <h2 class="identify-title" id="identify-title">Loading…</h2>
      <p class="identify-help muted" id="identify-help"></p>
    </div>

    <div class="identify-answers" id="identify-answers" aria-live="polite"></div>

    <div class="identify-meta">
      <span class="muted" id="identify-count"></span>
    </div>
  </div>

  {# =============================================================================
    Matches (standardized table)
    - Uses the same table classes as All Pastas / Home results.
    - Sortable headers are wired via the embedded script below.
  ============================================================================= #}
  <div class="identify-results" id="identify-results" hidden>
    <div class="results-head">
      <h2 class="h2">Matches</h2>
      <p class="muted" id="identify-results-count"></p>
    </div>

    {% call pastaResultsTable(
      "identify",
      "table-wrap table-wrap--results",
      "Identify matches table",
      "",
      "",
      "identify-results-table",
      "data-table data-table--results js-sortable-table",
      "Identify matches table",
      "",
      "identify-results-body"
    ) %}
      {# Rows rendered by JS #}
    {% endcall %}
  </div>

  <div class="identify-bottom-bar" role="navigation" aria-label="Identify controls">
    <button class="btn secondary" type="button" id="identify-back" disabled>Back</button>
    <button class="btn secondary" type="button" id="identify-reset">Reset</button>
    <button class="btn" type="button" id="identify-toggle-results" hidden>Show all</button>
  </div>
</section>

<script type="application/json" id="identify-data">
{{ identifyData | dump | safe }}
</script>

<script>
(function () {
{# ============================================================================ #}
{# Identify logic (embedded) #}
{# ---------------------------------------------------------------------------- #}
{# NOTE #}
{# - This script is intentionally embedded to keep Identify self-contained. #}
{# - It renders matches into an All-Pastas-style table with sortable headers. #}
{# - It sets window.__pastaIdentifyInit to prevent double-init if other scripts #}
{# attempt to attach Identify behavior. #}
{# ============================================================================ #}
  if (window.__pastaIdentifyInit) return;
  window.__pastaIdentifyInit = true;

  const $ = (sel, root = document) => root.querySelector(sel);

  const els = {
    app: $("#identify-app"),
    title: $("#identify-title"),
    kicker: $("#identify-kicker"),
    help: $("#identify-help"),
    answers: $("#identify-answers"),
    count: $("#identify-count"),

    resultsCard: $("#identify-results"),
    resultsCount: $("#identify-results-count"),

    resultsTable: $("#identify-results-table"),
    resultsBody: $("#identify-results-body"),

    btnBack: $("#identify-back"),
    btnReset: $("#identify-reset"),
    btnToggleResults: $("#identify-toggle-results"),

    dataScript: $("#identify-data"),
  };

{# ImageKit bases #}
  const IK_THUMBS_BASE = "https://ik.imagekit.io/mevius/pasta/thumbs/";
  const IK_IDENTIFY_BASE = "https://ik.imagekit.io/mevius/pasta/identify/";
  const FALLBACK_THUMB = "pending.png";

{# UX tuning #}
  const AUTO_SHOW_RESULTS_THRESHOLD = Infinity; // show results after every question


{# Results sizing #}
  const DEFAULT_RESULTS_LIMIT = 60;
  const SHOW_MORE_STEP = 60;

{# Sorting state for the results table #}
  let sortKey = "name";
  let sortDir = "ascending";

  const isUrl = (s) => /^https?:\/\//i.test(String(s || "").trim());

  const fileNameOnly = (s) => {
    const str = String(s || "").trim();
    if (!str) return "";
    const clean = str.split("#")[0].split("?")[0];
    const parts = clean.split("/");
    return parts[parts.length - 1] || "";
  };

  const thumbUrlFor = (thumbRaw) => {
    if (isUrl(thumbRaw)) return String(thumbRaw).trim();
    const fn = fileNameOnly(thumbRaw);
    return IK_THUMBS_BASE + (fn || FALLBACK_THUMB);
  };

  const identifyIconUrlFor = (file) => IK_IDENTIFY_BASE + file;

  const answerIconFor = (questionKey, value) => {
    if (value === "__ns__") return identifyIconUrlFor(`${questionKey}-notsure.png`);
    return identifyIconUrlFor(`${questionKey}-${value}.png`);
  };

  if (!els.app || !els.dataScript) return;

  let raw = [];
  try {
    raw = JSON.parse(els.dataScript.textContent || "[]");
  } catch (e) {
    console.error("Identify: failed to parse identify-data JSON", e);
    if (els.title) els.title.textContent = "Error loading data";
    if (els.help) els.help.textContent = "Could not parse pasta data on this page.";
    return;
  }

  const TYPE_LABELS = {
    strand: "Strand",
    tube: "Tube",
    ribbon: "Ribbon",
    sheet: "Sheet",
    short: "Short cut",
    stuffed: "Stuffed",
    soup: "Soup (Pastina)",
    ring: "Ring",
    dumpling: "Dumpling",
  };

  const TYPE_DESCS = {
    strand: "Long, thin noodles (round or slightly flattened).",
    tube: "Hollow pasta designed to hold sauce inside.",
    ribbon: "Long, flat strips like fettuccine-style cuts.",
    sheet: "Sheets used for layering or cutting (lasagna-style).",
    short: "Short shapes that scoop, trap, or cling to sauce.",
    stuffed: "Filled pasta (pockets, pillows, or sealed edges).",
    soup: "Tiny pasta made for spoons and brothy soups.",
    ring: "Rings that catch sauce in openings.",
    dumpling: "Pasta-like dumplings (often irregular or rustic).",
  };

  const normalize = (v) => String(v || "").trim().toLowerCase();

{# --------------------------------------------------------------------------- #}
{# Boolean normalization #}
{# --------------------------------------------------------------------------- #}
{# Your CSV has evolved over time, so boolean-like fields may appear as: #}
{# - 1 / 0 #}
{# - true / false #}
{# - yes / no #}
{# - y / n #}
{# - (blank) #}
{#  #}
{# Identify questions store answers as "yes" or "no" (plus "__ns__" for Not sure). #}
{# This helper coerces any of the above into: "yes" | "no" | "". #}
{# --------------------------------------------------------------------------- #}
  const coerceYesNo = (raw) => {
    const v = String(raw ?? "").trim().toLowerCase();
    if (!v) return "";
    if (v === "yes" || v === "y" || v === "true" || v === "1") return "yes";
    if (v === "no" || v === "n" || v === "false" || v === "0") return "no";
    return v; // allow future explicit tokens without breaking
  };


{# Canonical dataset (what Identify filters against) #}
  const initial = raw.map((r) => ({
    slug: r.slug,
    name: r.name,
    category: String(r.category || r.type || "").trim(),
    type: normalize(r.type),
    size: normalize(r.size),
    hollow: normalize(r.hollow),
    ridged: normalize(r.ridged),
    twisted: normalize(r.twisted),
    curved: normalize(r.curved),
    stuffed: normalize(r.stuffed),
    also: String(r.also || ""),
    thumb: String(r.thumb || ""),
  }));

{# Question definitions (same as before) #}
  const QUESTION_DEFS = [
    {
      key: "type",
      title: "What general type is it?",
      help: "Start broad - this narrows the list quickly.",
      kind: "enum",
      values: Object.keys(TYPE_LABELS),
      label: (v) => TYPE_LABELS[v] || v,
      desc: (v) => TYPE_DESCS[v] || "",
      icon: (v) => identifyIconUrlFor(`${v}.png`),
    },
    {
      key: "hollow",
      title: "Is it hollow?",
      help: "Hollow pasta has a visible tube or cavity.",
      kind: "bool",
      descYes: "You can see a tube or opening through the shape.",
      descNo: "Solid pasta - no tube or cavity.",
    },
    {
      key: "ridged",
      title: "Does it have ridges?",
      help: "Ridges (rigate) help grip sauce.",
      kind: "bool",
      descYes: "Noticeable grooves or ridges on the surface.",
      descNo: "Mostly smooth surface.",
    },
    {
      key: "twisted",
      title: "Is it twisted?",
      help: "Twisted shapes include spirals and corkscrews.",
      kind: "bool",
      descYes: "Spiraled or corkscrew-like geometry.",
      descNo: "Not spiraled or twisted.",
    },
    {
      key: "curved",
      title: "Is it curved?",
      help: "Curved shapes include elbows, crescents, and arcs.",
      kind: "bool",
      descYes: "Bent or arced rather than straight.",
      descNo: "Straight rather than bent.",
    },
    {
      key: "size",
      title: "What size is it?",
      help: "If you’re unsure, pick “Not sure” - size is often the least reliable.",
      kind: "enum",
      values: ["tiny", "small", "medium", "large"],
      label: (v) => v,
      icon: (v) => identifyIconUrlFor(`size-${v}.png`),
    },
  
{# ------------------------------------------------------------------------- #}
{# Optional "unlock more questions" fields (safe if empty in CSV). #}
{# ------------------------------------------------------------------------- #}
    {
      key: "crossSection",
      title: "Is it round or flat?",
      help: "This helps split spaghetti-like strands from ribbon-like noodles (and some short shapes).",
      kind: "enum",
      values: ["round", "flat", "other"],
      label: (v) => ({ round: "Round", flat: "Flat", other: "Other / not sure" }[v] || v),
      desc: (v) => ({
        round: "Looks like a round strand or cylinder.",
        flat: "Looks like a flat ribbon or sheet.",
        other: "Not clearly round or flat, or you’re not sure.",
      }[v] || ""),
      icon: (v) => identifyIconUrlFor(`crossSection-${v}.png`),
    },
    {
      key: "cutStyle",
      title: "How is it cut?",
      help: "Cut style is a strong discriminator for short shapes (straight, diagonal, pinched, folded).",
      kind: "enum",
      values: ["straight", "diagonal", "pinched", "folded"],
      label: (v) => ({ straight: "Straight", diagonal: "Diagonal", pinched: "Pinched", folded: "Folded" }[v] || v),
      desc: (v) => ({
        straight: "Ends look straight across.",
        diagonal: "Ends look angled (like penne).",
        pinched: "Looks pinched or pressed (creates a crease).",
        folded: "Looks folded into a pocket/shape.",
      }[v] || ""),
      icon: (v) => identifyIconUrlFor(`cutStyle-${v}.png`),
    },
    {
      key: "concave",
      title: "Is it concave - like a cup or little ear?",
      help: "Concave shapes scoop sauce (shells, cups, 'ears').",
      kind: "bool",
      descYes: "It forms a cup / scoop.",
      descNo: "It’s flat or tubular without a scooping cup.",
    },
    {
      key: "ruffles",
      title: "Does it have ruffled edges?",
      help: "Ruffles/frills often identify 'ruffled ribbon' or 'flower/bell' shapes.",
      kind: "bool",
      descYes: "Edges look wavy, frilly, or ruffled.",
      descNo: "Edges are smooth/clean.",
    },
    {
      key: "pastina",
      title: "Is it tiny - meant for soup (pastina)?",
      help: "Pastina are spoonable tiny shapes used in broths and soups.",
      kind: "bool",
      descYes: "Very small, spoonable pieces.",
      descNo: "Not tiny - more like a standard pasta portion.",
    },
];

{# Working state #}
  let working = initial.slice();
  let history = []; // [{ key, value, prevWorking }]
  let resultsPanelPreference = "show"; // auto | show | hide (default: show for "always see matches")
  let resultsLimit = DEFAULT_RESULTS_LIMIT;

  const setText = (el, txt) => { if (el) el.textContent = txt; };

{# Sorting #}
  function compare(a, b) {
    const aKey = (sortKey === "category" ? a.category : a.name) || "";
    const bKey = (sortKey === "category" ? b.category : b.name) || "";
    const cmp = String(aKey).localeCompare(String(bKey), "en", { sensitivity: "base" });
    return sortDir === "descending" ? -cmp : cmp;
  }

  function sortWorking() {
    working.sort(compare);
  }

{# Match count label #}
  function renderMatchesCount() {
    setText(els.count, `Matching: ${working.length}`);
  }

{# Show/hide results panel #}
  function showResultsPanel(show) {
    if (!els.resultsCard || !els.btnToggleResults) return;
    els.resultsCard.hidden = !show;
    els.btnToggleResults.hidden = false;

    if (!show) {
      els.btnToggleResults.textContent = "Show all";
    } else {
      els.btnToggleResults.textContent =
        resultsLimit >= working.length ? "Hide list" : "Show all";
    }
  }

  function shouldShowResultsPanel() {
    if (resultsPanelPreference === "show") return true;
    if (resultsPanelPreference === "hide") return false;
    return working.length <= AUTO_SHOW_RESULTS_THRESHOLD;
  }

{# Render results into the table body #}
  function renderResultsTable() {
    if (!els.resultsBody) return;

    els.resultsBody.innerHTML = "";

    const n = Math.min(working.length, resultsLimit);
    const slice = working.slice(0, n);

    for (const item of slice) {
      const tr = document.createElement("tr");
      tr.className = "data-row";
      tr.setAttribute("data-slug", item.slug);
      tr.setAttribute("data-name", item.name);
      tr.setAttribute("data-category", item.category || "");

{# Thumb cell #}
      const tdThumb = document.createElement("td");
      tdThumb.className = "data-table__thumb";

      const spanThumb = document.createElement("span");
      spanThumb.className = "thumb";
      spanThumb.setAttribute("aria-hidden", "true");

      const img = document.createElement("img");
      img.width = 56;
      img.height = 56;
      img.loading = "lazy";
      img.decoding = "async";
      img.alt = "";
      img.src = thumbUrlFor(item.thumb) + "?tr=w-56,h-56,f-auto,q-50";

      spanThumb.appendChild(img);
      tdThumb.appendChild(spanThumb);

{# Name (row header cell) #}
      const thName = document.createElement("th");
      thName.scope = "row";
      thName.className = "data-table__name";

      thName.textContent = item.name;

{# Category #}
      const tdCat = document.createElement("td");
      tdCat.className = "cell-category";
      tdCat.textContent = item.category || "";

{# Synonyms #}
      const tdSyn = document.createElement("td");
      tdSyn.className = "cell-synonyms";
      tdSyn.textContent = item.also || "";

      tr.appendChild(tdThumb);
      tr.appendChild(thName);
      tr.appendChild(tdCat);
      tr.appendChild(tdSyn);

      els.resultsBody.appendChild(tr);
    }

    setText(els.resultsCount, `${working.length} match${working.length === 1 ? "" : "es"}`);

{# Show-more row (spans all columns) #}
    if (!els.resultsCard.hidden && resultsLimit < working.length) {
      const trMore = document.createElement("tr");

      const tdMore = document.createElement("td");
      tdMore.colSpan = 4;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn secondary";
      btn.textContent = `Show more (${Math.min(working.length - resultsLimit, SHOW_MORE_STEP)})`;
      btn.addEventListener("click", () => {
        resultsLimit = Math.min(working.length, resultsLimit + SHOW_MORE_STEP);
        renderResultsTable();
        syncToggleLabel();
      });

      tdMore.appendChild(btn);
      trMore.appendChild(tdMore);
      els.resultsBody.appendChild(trMore);
    }
  }

{# Sort header wiring (local to Identify table) #}
  if (els.resultsBody) {
    els.resultsBody.addEventListener("click", (e) => {
      const interactive = e.target.closest("a, button, input, select, textarea, label");
      if (interactive) return;

      const row = e.target.closest("tr.data-row[data-slug]");
      if (!row || !els.resultsBody.contains(row)) return;

      const slug = String(row.getAttribute("data-slug") || "").trim();
      if (!slug) return;
      window.location.href = `/pasta/${slug}/`;
    });
  }

  function initTableSorting() {
    if (!els.resultsTable) return;

    const headers = Array.from(els.resultsTable.querySelectorAll("thead th[data-sort]"));
    if (!headers.length) return;

    function setSortState(activeKey, dir) {
      for (const th of headers) {
        const key = th.getAttribute("data-sort");
        th.setAttribute("aria-sort", key === activeKey ? dir : "none");
      }
      sortKey = activeKey;
      sortDir = dir;
    }

    function toggle(th) {
      const key = th.getAttribute("data-sort");
      const cur = th.getAttribute("aria-sort") || "none";

      let next = "ascending";
      if (cur === "ascending") next = "descending";
      if (cur === "descending") next = "ascending";

      setSortState(key, next);
      sortWorking();
      renderResultsTable();
    }

    for (const th of headers) {
      th.addEventListener("click", () => toggle(th));
      th.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          toggle(th);
        }
      });
    }

{# Ensure initial state #}
    setSortState("name", "ascending");
  }

  function syncToggleLabel() {
    if (!els.btnToggleResults || !els.resultsCard) return;
    if (els.resultsCard.hidden) {
      els.btnToggleResults.textContent = "Show all";
      return;
    }
    els.btnToggleResults.textContent =
      resultsLimit >= working.length ? "Hide list" : "Show all";
  }

{# Identify filtering helpers #}
  function questionAlreadyAnswered(key) {
    return history.some((h) => h.key === key);
  }

  function getQuestionCounts(q) {
    if (q.kind === "bool") {
      return {
        yes: getOptionCount(q.key, "yes"),
        no: getOptionCount(q.key, "no"),
        ns: getOptionCount(q.key, "__ns__"),
      };
    }

    if (q.kind === "enum") {
      const counts = {};
      for (const v of q.values || []) counts[v] = getOptionCount(q.key, v);
      counts.__ns__ = getOptionCount(q.key, "__ns__");
      return counts;
    }

    return { __ns__: working.length };
  }

  function isQuestionInformative(q) {
    const counts = getQuestionCounts(q);

    if (q.kind === "bool") {
      return counts.yes > 0 && counts.no > 0;
    }

    if (q.kind === "enum") {
      const nonZero = (q.values || []).filter((v) => (counts[v] || 0) > 0).length;
      return nonZero > 1;
    }

    return true;
  }

  function nextQuestion() {
{# Always force "type" first (it frames everything else). #}
    if (!questionAlreadyAnswered("type")) {
      const typeQ = QUESTION_DEFS.find((q) => q.key === "type");
      if (typeQ && isQuestionInformative(typeQ)) return typeQ;
    }

{# After type, pick the unanswered question that best splits the remaining set. #}
{# This avoids the "it only asks type, then size" problem when booleans are sparse. #}
    let best = null;
    let bestScore = -1;

    for (const q of QUESTION_DEFS) {
      if (questionAlreadyAnswered(q.key)) continue;
      if (!isQuestionInformative(q)) continue;

      const counts = getQuestionCounts(q);

{# Score heuristic: #}
{# - bool: bigger of min(yes,no) means a better split. #}
{# - enum: prefer questions with more non-zero buckets AND larger second-best bucket. #}
      let score = 0;

      if (q.kind === "bool") {
        score = Math.min(counts.yes || 0, counts.no || 0);
      } else if (q.kind === "enum") {
        const buckets = (q.values || []).map((v) => counts[v] || 0).filter((n) => n > 0).sort((a, b) => b - a);
        const nonZero = buckets.length;
        const second = buckets[1] || 0;
        score = nonZero * 1000 + second; // weight "multiple options" heavily
      } else {
        score = 1;
      }

      if (score > bestScore) {
        bestScore = score;
        best = q;
      }
    }

    return best;
  }

  function getOptionCount(key, value) {
    if (value === "__ns__") return working.length;

{# For bool questions, value will be "yes" or "no". #}
{# For enum questions, value will be one of the enum tokens. #}
    const desired = String(value).toLowerCase();

    return working.filter((p) => {
      const pvRaw = p[key];

{# If this key is one of our boolean-like fields, compare using yes/no coercion. #}
      if (key === "hollow" || key === "ridged" || key === "twisted" || key === "curved" || key === "stuffed" || key === "concave" || key === "ruffles" || key === "pastina") {
        return coerceYesNo(pvRaw) === desired;
      }

      return String(pvRaw || "").trim().toLowerCase() === desired;
    }).length;
  }

  function applyFilter(key, value) {
    const prev = working.slice();

    const desired = String(value).toLowerCase();

    working = working.filter((p) => {
      if (value === "__ns__") return true;

      const pvRaw = p[key];

{# If this key is one of our boolean-like fields, compare using yes/no coercion. #}
      if (key === "hollow" || key === "ridged" || key === "twisted" || key === "curved" || key === "stuffed" || key === "concave" || key === "ruffles" || key === "pastina") {
        return coerceYesNo(pvRaw) === desired;
      }

      return String(pvRaw || "").trim().toLowerCase() === desired;
    });

    history.push({ key, value, prevWorking: prev });
    sortWorking();
  }

  function goBack() {
    const last = history.pop();
    if (!last) return;
    working = last.prevWorking.slice();
    sortWorking();
  }

  function resetAll() {
    history = [];
    working = initial.slice();
    resultsLimit = DEFAULT_RESULTS_LIMIT;
    resultsPanelPreference = "auto";
    sortWorking();
  }

  function renderQuestion() {
    const q = nextQuestion();

    renderMatchesCount();

    if (!q) {
      setText(els.title, "Done");
      setText(els.kicker, "Here are your matches.");
      setText(els.help, "Use Back to change your last answer, or Reset to start over.");
      if (els.answers) els.answers.innerHTML = "";
      showResultsPanel(true);
      renderResultsTable();
      syncToggleLabel();
      return;
    }

    setText(els.title, q.title);
    setText(els.kicker, `Step ${history.length + 1}`);
    setText(els.help, q.help || "");

    if (els.btnBack) els.btnBack.disabled = history.length === 0;
    if (els.btnReset) els.btnReset.hidden = history.length === 0;

    showResultsPanel(shouldShowResultsPanel());
    renderResultsTable();
    syncToggleLabel();

    if (!els.answers) return;
    els.answers.innerHTML = "";
    els.answers.setAttribute("data-kind", q.kind);
    els.answers.setAttribute("data-key", q.key);

    const makeAnswer = (value, label, desc, iconUrl, count) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "identify-answer";

{# Bool questions (and enum Not sure) use glyphs (Y / N / ?) #}
      if (q.kind === "bool" || value === "__ns__") {
        const glyph = document.createElement("span");
        glyph.className = "identify-answer-glyph";
        glyph.textContent = value === "yes" ? "Y" : value === "no" ? "N" : "?";
        btn.appendChild(glyph);
      } else {
        const img = document.createElement("img");
        img.alt = "";
        img.loading = "lazy";
        img.decoding = "async";
        img.width = 56;
        img.height = 56;
        img.src = iconUrl || "";
        btn.appendChild(img);
      }

      const meta = document.createElement("span");
      meta.className = "identify-answer-meta";

      const title = document.createElement("span");
      title.className = "identify-answer-title";
      title.textContent = `${label} (${count})`;
      meta.appendChild(title);

      if (desc) {
        const d = document.createElement("span");
        d.className = "identify-answer-desc";
        d.textContent = desc;
        meta.appendChild(d);
      }

      btn.appendChild(meta);

      btn.addEventListener("click", () => {
        applyFilter(q.key, value);
        renderQuestion();
      });

      return btn;
    };

    if (q.kind === "enum") {
      const counts = getQuestionCounts(q);
      for (const v of q.values) {
        const count = counts[v] || 0;
        if (count <= 0) continue;

        els.answers.appendChild(
          makeAnswer(
            v,
            q.label ? q.label(v) : String(v),
            q.desc ? q.desc(v) : "",
            q.icon ? q.icon(v) : "",
            count
          )
        );
      }

      els.answers.appendChild(
        makeAnswer("__ns__", "Not sure", "Skip this question.", q.icon ? q.icon("__ns__") : "", counts.__ns__)
      );
    }

    if (q.kind === "bool") {
      const counts = getQuestionCounts(q);

      if (counts.yes > 0) {
        els.answers.appendChild(makeAnswer("yes", "Yes", q.descYes || "", answerIconFor(q.key, "yes"), counts.yes));
      }

      if (counts.no > 0) {
        els.answers.appendChild(makeAnswer("no", "No", q.descNo || "", answerIconFor(q.key, "no"), counts.no));
      }

      els.answers.appendChild(makeAnswer("__ns__", "Not sure", "Skip this question.", answerIconFor(q.key, "__ns__"), counts.__ns__));
    }

    if (q.kind === "single") {
      els.answers.appendChild(makeAnswer("__ns__", "Continue", "", "", working.length));
    }
  }

{# Controls #}
  if (els.btnBack) {
    els.btnBack.addEventListener("click", () => {
      goBack();
      renderQuestion();
    });
  }

  if (els.btnReset) {
    els.btnReset.addEventListener("click", () => {
      resetAll();
      renderQuestion();
    });
  }

  if (els.btnToggleResults) {
    els.btnToggleResults.addEventListener("click", () => {
      const currentlyHidden = Boolean(els.resultsCard && els.resultsCard.hidden);

      if (currentlyHidden) {
        resultsPanelPreference = "show";
        if (els.resultsCard) els.resultsCard.hidden = false;

{# When user explicitly requests the list, show everything. #}
        resultsLimit = working.length;
        renderResultsTable();
        syncToggleLabel();
      } else {
        resultsPanelPreference = "hide";
        if (els.resultsCard) els.resultsCard.hidden = true;
        syncToggleLabel();
      }
    });
  }

{# Init #}
  sortWorking();
  initTableSorting();
  renderQuestion();
})();
</script>
