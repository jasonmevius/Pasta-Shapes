/**
 * patch_manifest_from_suggestions.js
 * -----------------------------------------------------------------------------
 * PURPOSE
 * - Takes your current manifest.csv (used by download_images.js)
 * - Takes suggestions.csv (generated by the Commons API helper)
 * - Replaces broken Special:FilePath/<filename> URLs with the suggested
 *   best_filePath_url (which uses the real Commons filename).
 *
 * WHY
 * - Many of your 404s are NOT “missing images” - they are “wrong filename”.
 * - Commons file titles often contain spaces, punctuation, etc.
 * - Special:FilePath is strict about the actual filename.
 *
 * INPUTS (expected in this same folder):
 * - manifest.csv
 * - suggestions.csv
 *
 * OUTPUT
 * - manifest.patched.csv (safe output)
 *
 * OPTIONAL
 * - If you want to overwrite manifest.csv, flip OVERWRITE_MANIFEST = true
 * -----------------------------------------------------------------------------
 */

const fs = require("fs");
const path = require("path");

const ROOT = __dirname;
const MANIFEST_IN = path.join(ROOT, "manifest.csv");
const SUGGESTIONS_IN = path.join(ROOT, "suggestions.csv");

const MANIFEST_OUT = path.join(ROOT, "manifest.patched.csv");

// If you want to overwrite manifest.csv in-place, set this true.
const OVERWRITE_MANIFEST = false;

/**
 * Very small CSV reader.
 * Assumption: no embedded commas inside fields (true for our manifest + suggestions).
 */
function readCsv(filePath) {
  const lines = fs.readFileSync(filePath, "utf8").split(/\r?\n/).filter(Boolean);
  const header = lines[0].split(",").map((s) => s.trim());
  const rows = [];

  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(",");
    const obj = {};
    for (let c = 0; c < header.length; c++) obj[header[c]] = (cols[c] ?? "").trim();
    rows.push(obj);
  }
  return { header, rows };
}

/**
 * CSV writer.
 */
function writeCsv(filePath, header, rows) {
  const out = [];
  out.push(header.join(","));
  for (const r of rows) {
    out.push(header.map((h) => r[h] ?? "").join(","));
  }
  fs.writeFileSync(filePath, out.join("\n"), "utf8");
}

/**
 * Extract the filename from a Special:FilePath URL.
 * Example:
 *  https://commons.wikimedia.org/wiki/Special:FilePath/Bucatini%20all%27amatriciana.jpg
 * -> "Bucatini all'amatriciana.jpg"
 */
function filenameFromFilePathUrl(url) {
  const m = String(url).match(/\/Special:FilePath\/(.+)$/i);
  if (!m) return null;
  try {
    return decodeURIComponent(m[1]);
  } catch {
    // If decoding fails, just return raw tail (better than nothing).
    return m[1];
  }
}

function main() {
  if (!fs.existsSync(MANIFEST_IN)) {
    console.error(`Missing: ${MANIFEST_IN}`);
    process.exit(2);
  }
  if (!fs.existsSync(SUGGESTIONS_IN)) {
    console.error(`Missing: ${SUGGESTIONS_IN}`);
    process.exit(2);
  }

  const manifest = readCsv(MANIFEST_IN);
  const suggestions = readCsv(SUGGESTIONS_IN);

  // Build a lookup: original_filename -> best_filePath_url
  // Only use suggestions where "exists" is yes and best_filePath_url is populated.
  const map = new Map();
  for (const s of suggestions.rows) {
    const original = s.original;
    const exists = (s.exists || "").toLowerCase();
    const bestUrl = s.best_filePath_url;

    if (original && exists === "yes" && bestUrl) {
      map.set(original, bestUrl);
    }
  }

  let changed = 0;

  // Patch manifest URLs
  for (const row of manifest.rows) {
    const url = row.url || "";
    const filename = filenameFromFilePathUrl(url);

    // Only patch Commons Special:FilePath entries we have suggestions for.
    if (filename && map.has(filename)) {
      row.url = map.get(filename);
      changed++;
    }
  }

  writeCsv(MANIFEST_OUT, manifest.header, manifest.rows);

  if (OVERWRITE_MANIFEST) {
    fs.copyFileSync(MANIFEST_OUT, MANIFEST_IN);
  }

  console.log(`Patched rows: ${changed}`);
  console.log(`Wrote: ${MANIFEST_OUT}`);
  if (OVERWRITE_MANIFEST) console.log(`Also overwrote: ${MANIFEST_IN}`);
}

main();
